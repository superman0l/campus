# 单点导航中的Dijkstra算法

我们将地图中的地点抽象成图论问题中的节点，导航点之间的道路抽象成节点与节点之间，带有正数权值的双向边。下文中的N指点的个数，M指边的个数。

单点导航功能要实现的，即找出，出发点确定，仅有一个目的地时的最佳路径，也就是图论中的最短路径问题。

由于边的权值均为正数，所以我们可以采用Dijkstra算法解决该问题(Floyd算法与Bellman-Ford算法时间复杂度较劣)。

同时，为了进一步降低时间复杂度，我们结合了STL中的优先队列，对Dijkstra算法进行优化，将原本O(N^2)的时间复杂度优化为O(N*logM)。



# 多点导航中的动态规划算法

承接单点导航的思路，我们将地图抽象成图。而多点导航，即出发点确定，有多个目的地时的最佳路径。

由于边的权值都为正数，显然我们可以复用单点导航的算法，预先处理出目的地彼此之间的最短路径及长度，那么唯一会影响总路径的，就是目的地的访问顺序。

若采取暴力枚举目的地访问顺序的方法，时间复杂度是O(N!)，当目的地数量为20时，需要进行约2.5e18次运算，大概需要28935天完成计算，显然不符合我们的需求。

因此，我们采用动态规划的算法，即在寻找最优结果的过程中，记录最优子结果，以达到减少重复计算，优化时间复杂度的目的。

具体而言我们使用一个bit vector表示节点是否被访问过，若访问过，则将对应bit置1，否则置0，若有N个目的地，则对应的bit vector大小应为(2^N)，同时，我们使用一个数字表示以访问的节点中，最后访问的节点编号。

如dp[i]\[j]，其中i是上述bit vector到正整数的映射，j是最后访问的节点，假设我们已经知道，到达过i中所有置1节点，且目前处于j的最佳路径。我们可以枚举i中置0节点，假设该节点就是下一个目的节点，对最佳子结果进行更新。

时间复杂度分析：一共有O(N*2^N)种状态，而每个状态可以进行N次转移，故总时间复杂度为O(2^N\*N^2)，当目的地数量为20时，需要进行约4e8次运算，约400ms内即可完成。